# -*- coding: utf-8 -*-
"""WIP13_of_SQL_Gen_w_llama3 (GROQ_SL).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16tzebyUs-w7uAM9buXPcTrGwjBzz5Pyz
"""

import streamlit as st
import mysql.connector
from mysql.connector import Error
import os
from langchain.prompts import ChatPromptTemplate
from langchain_groq import ChatGroq
import re
import pandas as pd
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain.memory import ChatMessageHistory
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Environment variables
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
MYSQL_HOST = os.getenv("MYSQL_HOST")
MYSQL_PORT = os.getenv("MYSQL_PORT")
MYSQL_USER = os.getenv("MYSQL_USER")
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD")
MYSQL_DB = os.getenv("MYSQL_DB")

try:
    db_connection = mysql.connector.connect(
        host=MYSQL_HOST,
        port=MYSQL_PORT,
        user=MYSQL_USER,
        passwd=MYSQL_PASSWORD,
        database=MYSQL_DB
    )
    st.write("Connected to MySQL server")
except Error as e:
    st.write("Error while connecting to MySQL:", e)

def build_schema_desc(cursor, table_name, prefix=""):
    """Build schema description for a MySQL table."""
    desc = []
    cursor.execute(f"DESCRIBE {table_name}")
    for column in cursor.fetchall():
        d = f"{prefix}- Name: {column[0]}, Type: {column[1]}, Null: {column[2]}, Key: {column[3]}"
        desc.append(d)
    return desc

def fetch_schemas(db_connection):
    """Fetch schema descriptions for all tables in database."""
    schemas = []
    simple_table_list = []
    cursor = db_connection.cursor()
    cursor.execute("SHOW TABLES")
    tables = cursor.fetchall()
    for table in tables:
        table_name = table[0]
        simple_table_list.append(f"- {table_name}")
        schema_desc = [f"Schema for {table_name}:"]
        schema_desc += build_schema_desc(cursor, table_name)
        schema_desc.append("")  # For newline
        schemas += schema_desc
    cursor.close()
    return "\n".join(simple_table_list) + "\n\n" + "\n".join(schemas)

def extract_sql(input_text):
    # Check if the input contains triple backticks
    if '```' in input_text:
        # Regex to extract content within triple backticks
        pattern = re.compile(r'```(.*?)```', re.DOTALL)
        match = pattern.search(input_text)
        if match:
            return match.group(1).strip()  # Return the cleaned, extracted SQL
    # If no triple backticks are found, return the input as is
    return input_text.strip()

llm_groq = ChatGroq(temperature=0.2, model_name="llama3-70b-8192")
template = """Based on the schema below, and the message history, write a
SQL query that answers the question/request.

Remember to UNNEST repeated records and make sure only to use existing fields in the schema:

schema:{schema}

Question: {question}

Message history: {messages}

SQL Query:"""
prompt = ChatPromptTemplate.from_template(template)

hist = ChatMessageHistory()

def get_schema(_):
    return fetch_schemas(db_connection)

def get_messages(_):
    return hist.messages

sql_response = (
    RunnablePassthrough.assign(schema=get_schema, messages=get_messages)
    | prompt
    | llm_groq
    | StrOutputParser()
)

def execute_query_with_retries(my_query, max_attempts=5):
    attempts = 0
    while attempts < max_attempts:
        attempts += 1
        st.write(f"Attempt {attempts} of {max_attempts}")
        # Invoke the external SQL service
        st.write("Generating the SQL")
        res = sql_response.invoke({"question": my_query})
        clean_sql = extract_sql(res)
        st.write(f"Generated SQL Query:\n{clean_sql}")
        try:
            st.write("Attempting to run the query and convert it to a DataFrame")
            cursor = db_connection.cursor()
            cursor.execute(clean_sql)
            result = cursor.fetchall()
            dataframe = pd.DataFrame(result, columns=[x[0] for x in cursor.description])
            st.write("Query executed successfully.")
            cursor.close()
            return dataframe
        except Exception as e:
            # Print or store the error message
            error_message = str(e)
            st.write("Query failed with the following error:")
            st.write(error_message)
            if attempts == max_attempts:
                st.write("Reached maximum attempt limit. Stopping retries.")
                return None  # Return None if all retries fail

def main():
    st.title("SQL Query Generator")

    if st.button("Connect to MySQL"):
        try:
            db_connection = mysql.connector.connect(
                host=MYSQL_HOST,
                port=MYSQL_PORT,
                user=MYSQL_USER,
                passwd=MYSQL_PASSWORD,
                database=MYSQL_DB
            )
            st.write("Connected to MySQL server")
        except Error as e:
            st.write("Error while connecting to MySQL:", e)

    my_query = st.text_input("Enter your query:", "Get all of the order numbers associated with the first 3 customers.")
    if st.button("Generate and Run SQL Query"):
        df = execute_query_with_retries(my_query)
        if df is not None:
            st.write(df)

if __name__ == "__main__":
    main()